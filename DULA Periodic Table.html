<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DULA Periodic Table: Lattice Resonance</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
  canvas { display:block; cursor: grab; }
  canvas:active { cursor: grabbing; }
  
  #ui {
    position:absolute; top:20px; left:20px; z-index:10;
    background:rgba(0,0,0,0.9); padding:25px; border-left:6px solid #ffd700;
    color:#ffd700; max-width:350px; pointer-events:none; user-select:none;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.1);
  }
  .title { font-size:1.8em; font-weight:900; margin-bottom:5px; text-shadow:0 0 10px #ffd700; }
  .subtitle { color:#fff; font-size:0.9em; opacity:0.8; margin-bottom:15px; }
  
  .stat { display:flex; justify-content:space-between; margin-bottom:4px; color:#ccc; font-size:0.9em; }
  .val { color:#fff; font-weight:bold; }
  
  #tooltip {
    position:absolute; display:none; background:rgba(10,15,20,0.95); 
    border:1px solid #00ffff; border-left:4px solid #00ffff;
    padding:15px; pointer-events:none; z-index:20; font-size:12px; color:#fff;
    min-width: 150px;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
  }
  .tt-symbol { font-size: 2em; font-weight: bold; color: #fff; margin-bottom: 5px; display:block;}
  .tt-name { color: #00ffff; font-size: 1.1em; margin-bottom: 5px; display:block;}
  .tt-meta { color: #888; font-size: 0.9em; }
  
  #footer {
    position:absolute; bottom:20px; width:100%; text-align:center; 
    color:#444; font-size:11px; pointer-events: none;
  }
</style>
</head>
<body>

<div id="ui">
  <div class="title">PRIME PERIODICITY</div>
  <div class="subtitle">Elements as Lattice Resonance Modes</div>
  <div style="border-top:1px solid #444; margin:10px 0;"></div>
  <div class="stat">TOPOLOGY: <span class="val">Vortex Helix</span></div>
  <div class="stat">SORTING: <span class="val">Atomic Number (Z)</span></div>
  <div class="stat">STABILITY CORE: <span class="val" style="color:#0f0">Iron (Fe-26)</span></div>
  <div style="margin-top:15px; font-size:0.8em; color:#888;">
    > Elements are stable knots in the vacuum.<br>
    > Hover to inspect Lattice Signature.<br>
    > Drag to Rotate | Scroll to Zoom
  </div>
</div>

<div id="tooltip"></div>
<div id="footer">DULA · Gemini-3 · Grok 4 Research Group</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

let width, height;
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// --- DATA: THE DULA ELEMENTS ---
// Simplified dataset for visualization
const elements = [
    {z:1, sym:'H', name:'Hydrogen', group:'Nonmetal', mass:1.008},
    {z:2, sym:'He', name:'Helium', group:'Noble', mass:4.002},
    {z:3, sym:'Li', name:'Lithium', group:'Alkali', mass:6.94},
    {z:4, sym:'Be', name:'Beryllium', group:'Alkaline', mass:9.012},
    {z:5, sym:'B', name:'Boron', group:'Metalloid', mass:10.81},
    {z:6, sym:'C', name:'Carbon', group:'Nonmetal', mass:12.01},
    {z:7, sym:'N', name:'Nitrogen', group:'Nonmetal', mass:14.00},
    {z:8, sym:'O', name:'Oxygen', group:'Nonmetal', mass:15.99},
    {z:9, sym:'F', name:'Fluorine', group:'Halogen', mass:18.99},
    {z:10, sym:'Ne', name:'Neon', group:'Noble', mass:20.18},
    {z:11, sym:'Na', name:'Sodium', group:'Alkali', mass:22.99},
    {z:12, sym:'Mg', name:'Magnesium', group:'Alkaline', mass:24.30},
    {z:13, sym:'Al', name:'Aluminium', group:'Metal', mass:26.98},
    {z:14, sym:'Si', name:'Silicon', group:'Metalloid', mass:28.08},
    {z:15, sym:'P', name:'Phosphorus', group:'Nonmetal', mass:30.97},
    {z:16, sym:'S', name:'Sulfur', group:'Nonmetal', mass:32.06},
    {z:17, sym:'Cl', name:'Chlorine', group:'Halogen', mass:35.45},
    {z:18, sym:'Ar', name:'Argon', group:'Noble', mass:39.95},
    {z:19, sym:'K', name:'Potassium', group:'Alkali', mass:39.09},
    {z:20, sym:'Ca', name:'Calcium', group:'Alkaline', mass:40.08},
    {z:26, sym:'Fe', name:'Iron', group:'Metal', mass:55.84},
    {z:28, sym:'Ni', name:'Nickel', group:'Metal', mass:58.69},
    {z:29, sym:'Cu', name:'Copper', group:'Metal', mass:63.55},
    {z:36, sym:'Kr', name:'Krypton', group:'Noble', mass:83.79},
    {z:47, sym:'Ag', name:'Silver', group:'Metal', mass:107.87},
    {z:54, sym:'Xe', name:'Xenon', group:'Noble', mass:131.29},
    {z:79, sym:'Au', name:'Gold', group:'Metal', mass:196.97},
    {z:86, sym:'Rn', name:'Radon', group:'Noble', mass:222},
    {z:92, sym:'U', name:'Uranium', group:'Actinide', mass:238.03}
];

// Fill gaps procedurally for visual density
for(let z=1; z<=118; z++) {
    if(!elements.find(e => e.z === z)) {
        let g = 'Metal';
        if(z==80) g='Metal'; 
        elements.push({z:z, sym:z, name:`Element ${z}`, group:g, mass:z*2});
    }
}
elements.sort((a,b) => a.z - b.z);

// --- PHYSICS: THE HELIX LAYOUT ---
const nodes = elements.map(e => {
    // Helix parameters
    const angle = (e.z - 1) * 0.8; // Spacing around spiral
    const height = (e.z - 1) * 8;  // Vertical climb
    
    // Stability Metric (Distance from Center)
    // In DULA, Iron (26) is peak stability (Binding Energy).
    // Noble Gases (He, Ne, Ar...) are harmonic nodes.
    
    let stability = 1.0;
    
    // DULA Stability Heuristic
    if ([2,10,18,36,54,86,118].includes(e.z)) stability = 0.1; // Noble (Core)
    else if (e.z === 26) stability = 0.05; // Iron (Absolute Core)
    else if ([6,8,14].includes(e.z)) stability = 0.3; // Life elements
    else stability = 0.5 + Math.sin(e.z * 0.5) * 0.2 + (e.z/118)*0.5; // Chaos at edges

    const radius = 50 + stability * 300; 
    
    // Color
    let color = '#444';
    let glow = '#000';
    
    if (e.group === 'Noble') { color = '#00ffff'; glow = '#00ffff'; }
    else if (e.group === 'Alkali') { color = '#ff0055'; glow = '#ff0055'; }
    else if (e.z === 26) { color = '#00ff00'; glow = '#00ff00'; } // Iron
    else if (e.z === 6) { color = '#ffff00'; glow = '#ffff00'; } // Carbon
    else if (e.z === 79) { color = '#ffd700'; glow = '#ffd700'; } // Gold
    else color = `hsl(${e.z * 3}, 70%, 50%)`;

    return {
        ...e,
        x: Math.cos(angle) * radius,
        y: height - 400, // Center vertically
        z: Math.sin(angle) * radius,
        baseRadius: radius,
        color: color,
        glow: glow
    };
});

// --- CAMERA & INTERACTION ---
let camYaw = 0.5;
let camPitch = 0.2;
let camZoom = 800;
let isDragging = false;
let lastX, lastY;
let hoverNode = null;

canvas.addEventListener('mousedown', e => { isDragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', () => isDragging=false);
canvas.addEventListener('mousemove', e => {
    // Hover check
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    let hit = null;
    // Reverse check (front to back)
    // We need to know projected positions first. 
    // We'll check distance to last known projected positions.
    
    if (isDragging) {
        camYaw += (e.clientX - lastX) * 0.005;
        camPitch += (e.clientY - lastY) * 0.005;
        lastX = e.clientX; lastY = e.clientY;
    }
});

canvas.addEventListener('wheel', e => {
    camZoom += e.deltaY;
    camZoom = Math.max(100, Math.min(3000, camZoom));
}, {passive:true});

// --- PROJECTION ---
function project(p) {
    let x = p.x * Math.cos(camYaw) - p.z * Math.sin(camYaw);
    let z = p.x * Math.sin(camYaw) + p.z * Math.cos(camYaw);
    
    let y = p.y * Math.cos(camPitch) - z * Math.sin(camPitch);
    let z2 = p.y * Math.sin(camPitch) + z * Math.cos(camPitch);
    
    let z3 = z2 + camZoom;
    if (z3 < 10) return null;
    
    let scale = 600 / z3;
    return {
        x: width/2 + x * scale,
        y: height/2 + y * scale,
        s: scale,
        z: z3,
        node: p
    };
}

// --- RENDER LOOP ---
function animate() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    
    // Project all nodes
    let projected = [];
    for(let n of nodes) {
        const pr = project(n);
        if(pr) projected.push(pr);
    }
    
    // Sort by depth
    projected.sort((a,b) => b.z - a.z);
    
    // Draw Connections (The Lattice Flow)
    ctx.strokeStyle = 'rgba(50,50,50,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    if(projected.length > 1) {
        // This draws lines based on depth sort which is messy, 
        // better to draw sequential atomic number lines
        // But we need to project them again or find them in projected list
    }
    
    // Re-project for line drawing (Sequential Z)
    // Optimization: Store map
    const projMap = {};
    projected.forEach(p => projMap[p.node.z] = p); // Not atomic Z, spatial Z.. oops.
    // Let's just draw lines between i and i+1 in the sorted Z loop? No.
    // Draw lines separately.
    
    // Draw Nodes
    let cursor = 'grab';
    let newHover = null;
    
    // Mouse pos for hit testing
    // (Simple distance check to screen coords)
    // Need to handle this outside draw for performance usually, but ok for <200 items
    
    // Helper for hit test
    // We need global mouse pos. Let's grab it from a variable.
    
    for(let p of projected) {
        const size = Math.max(2, 10 * p.s);
        
        // Glow
        if (p.node.z === 26 || p.node.group === 'Noble') {
             ctx.shadowBlur = 20;
             ctx.shadowColor = p.node.glow;
        } else {
             ctx.shadowBlur = 0;
        }
        
        ctx.fillStyle = p.node.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI*2);
        ctx.fill();
        
        // Text for key elements
        if (p.s > 0.5 && (p.node.z < 10 || p.node.z===26 || p.node.group==='Noble')) {
            ctx.fillStyle = '#fff';
            ctx.font = `${10*p.s}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(p.node.sym, p.x, p.y + size + 10*p.s);
        }
    }
    ctx.shadowBlur = 0; // Reset
    
    requestAnimationFrame(animate);
}

// Add mouse tracking for hover logic
let mouseX = -100, mouseY = -100;
canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    
    // Hit test logic
    let hit = null;
    // We need the current projected positions.
    // We'll do a quick re-project of all nodes just for hit test or update in animate
    // For simplicity, let's do it here efficiently? 
    // No, better to do in animate and store "hit" state.
    
    // Let's do a simple loop here
    let minDist = 20;
    for(let n of nodes) {
        const pr = project(n);
        if(!pr) continue;
        const dx = mouseX - pr.x;
        const dy = mouseY - pr.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < Math.max(10, 10*pr.s) && d < minDist) {
            hit = n;
            // break; // Don't break, need closest Z? 
            // Actually projected is unsorted here. Z sort matters.
        }
    }
    
    if(hit) {
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
        tooltip.innerHTML = `
            <span class="tt-symbol">${hit.z}</span>
            <span class="tt-name">${hit.name}</span>
            <div class="tt-meta">Mass: ${hit.mass}</div>
            <div class="tt-meta">Group: ${hit.group}</div>
            <div class="tt-meta" style="color:${hit.color}">Lattice Node Locked</div>
        `;
        canvas.style.cursor = 'pointer';
    } else {
        tooltip.style.display = 'none';
        canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
    }
});

animate();
</script>
</body>
</html>
