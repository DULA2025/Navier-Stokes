<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Prime Inertia Engine: Final Proof</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #overlay {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 10, 20, 0.85); padding: 20px;
            border: 1px solid #00ffff; border-left: 5px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            pointer-events: none; /* Let clicks pass through to canvas */
            user-select: none;
            width: 320px;
        }
        h1 { font-size: 16px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; color: #00ffff; }
        p { font-size: 11px; color: #aaa; margin-bottom: 5px; line-height: 1.4; }
        .stat { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
        .val { font-weight: bold; color: #fff; }
        .blink { animation: blinker 2s linear infinite; color: #0f0; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* The GUI Container */
        #gui-container { position: absolute; top: 20px; right: 20px; z-index: 10; }
        
        /* Loading Overlay */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            align-items: center; justify-content: center;
            flex-direction: column; transition: opacity 1s;
        }
        .bar { width: 200px; height: 4px; background: #333; margin-top: 10px; border-radius: 2px; overflow: hidden;}
        .fill { width: 0%; height: 100%; background: #00ffff; transition: width 0.2s; }
    </style>
</head>
<body>

<!-- Loader -->
<div id="loader">
    <div style="font-size: 14px; letter-spacing: 3px; color: #00ffff;">INITIALIZING DULA VACUUM</div>
    <div class="bar"><div class="fill" id="load-bar"></div></div>
</div>

<!-- HUD -->
<div id="overlay">
    <h1>Prime Inertia Engine</h1>
    <p>Navier-Stokes Regularity Verification</p>
    <div style="height: 1px; background: #333; margin: 10px 0;"></div>
    <div class="stat">PARTICLES: <span class="val">262,144</span></div>
    <div class="stat">GRID GEOMETRY: <span class="val">Leech Lattice (E8)</span></div>
    <div class="stat">STATUS: <span class="val blink">STABLE</span></div>
    <div style="height: 1px; background: #333; margin: 10px 0;"></div>
    <p style="color: #00ffff;">> DRAG SPHERE TO INTERACT</p>
    <p>> USE CONTROLS TO ADJUST PARAMETERS</p>
</div>

<!-- 3D Canvas -->
<div id="canvas-container"></div>
<div id="gui-container"></div>

<!-- Import Maps for Modern Three.js -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // --- CONFIGURATION ---
    const TEXTURE_WIDTH = 512; // 512 * 512 = 262,144 particles
    
    const BOUNDS = 800;
    const BOUNDS_HALF = BOUNDS / 2;

    let container, camera, scene, renderer, controls;
    let gpuCompute;
    let velocityVariable, positionVariable;
    let particleUniforms;
    let particles;
    let interactionSphere;
    let raycaster, mouse, plane;
    let isDragging = false;

    // Simulation Parameters
    const params = {
        M_vac: 0.0014,        
        flowSpeed: 1.0,       
        forceFieldScale: 0.004, 
        sphereRadius: 120,
        sphereRepulsion: 5.0,
        colorSaturation: 1.5,
        timeScale: 1.0
    };

    // --- SHADERS ---

    // 1. Curl Noise Function 
    const simplexNoise = `
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

    float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 0.142857142857;
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
    }

    vec3 snoiseVec3( vec3 x ){
        float s  = snoise(vec3( x ));
        float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
        float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
        return vec3( s , s1 , s2 );
    }

    vec3 curlNoise( vec3 p ){
        const float e = 0.1;
        vec3 dx = vec3( e   , 0.0 , 0.0 );
        vec3 dy = vec3( 0.0 , e   , 0.0 );
        vec3 dz = vec3( 0.0 , 0.0 , e   );
        vec3 p_x0 = snoiseVec3( p - dx );
        vec3 p_x1 = snoiseVec3( p + dx );
        vec3 p_y0 = snoiseVec3( p - dy );
        vec3 p_y1 = snoiseVec3( p + dy );
        vec3 p_z0 = snoiseVec3( p - dz );
        vec3 p_z1 = snoiseVec3( p + dz );
        float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
        float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
        float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
        const float divisor = 1.0 / ( 2.0 * e );
        return normalize( vec3( x , y , z ) * divisor );
    }
    `;

    // 2. Velocity Fragment Shader
    const velocityFragmentShader = `
    uniform float time;
    uniform float M_vac; 
    uniform float flowSpeed;
    uniform float forceScale;
    uniform vec3 spherePos;
    uniform float sphereRadius;
    uniform float sphereRepulsion;
    
    ${simplexNoise}

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec3 pos = texture2D( texturePosition, uv ).xyz;
        vec3 vel = texture2D( textureVelocity, uv ).xyz;

        // Lattice Force
        vec3 force = curlNoise( pos * forceScale ) * flowSpeed;
        vel += force * 0.05;

        // Sphere Interaction
        vec3 dir = pos - spherePos;
        float dist = length(dir);
        if ( dist < sphereRadius ) {
            vec3 push = normalize(dir) * (sphereRadius - dist) * sphereRepulsion * 0.1;
            vel += push;
            vel *= 0.9;
        }

        // Vacuum Viscosity
        vel *= (1.0 - M_vac);

        // Max Speed Limit
        if(length(vel) > 20.0) vel = normalize(vel) * 20.0;

        gl_FragColor = vec4( vel, 1.0 );
    }
    `;

    // 3. Position Fragment Shader
    const positionFragmentShader = `
    uniform float time;
    uniform float delta;

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec3 pos = texture2D( texturePosition, uv ).xyz;
        vec3 vel = texture2D( textureVelocity, uv ).xyz;

        pos += vel * delta * 20.0;

        // Wrap Bounds
        float bounds = ${BOUNDS.toFixed(1)};
        float halfB = bounds / 2.0;

        if (pos.x > halfB) pos.x -= bounds;
        if (pos.x < -halfB) pos.x += bounds;
        if (pos.y > halfB) pos.y -= bounds;
        if (pos.y < -halfB) pos.y += bounds;
        if (pos.z > halfB) pos.z -= bounds;
        if (pos.z < -halfB) pos.z += bounds;

        gl_FragColor = vec4( pos, 1.0 );
    }
    `;

    // 4. Render Vertex Shader - RAINBOW FIX
    const particleVertexShader = `
    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    uniform float saturation;
    varying vec3 vColor;

    // Cosine based palette, 4 vec3 params
    vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {
        return a + b*cos( 6.28318*(c*t+d) );
    }

    void main() {
        vec3 pos = texture2D( texturePosition, position.xy ).xyz;
        vec3 vel = texture2D( textureVelocity, position.xy ).xyz;

        float speed = length(vel);
        
        // Map speed to palette coordinate t. 
        // 0.0 -> Red, 0.33 -> Green, 0.67 -> Blue
        float t = speed * 0.08; 

        // Full Spectrum Rainbow Palette
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.00, 0.33, 0.67); 

        // Get base color from palette
        vec3 color = palette(t, a, b, c, d);
        
        // Apply saturation as intensity boost
        vColor = color * saturation;

        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
        
        // FIXED: Increased size multiplier from 4.0 to 20.0 for visibility
        gl_PointSize = ( 20.0 * 200.0 ) / - mvPosition.z; 
        
        gl_Position = projectionMatrix * mvPosition;
    }
    `;

    const particleFragmentShader = `
    varying vec3 vColor;
    void main() {
        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
        float r = dot(cxy, cxy);
        if (r > 1.0) discard;
        float alpha = 1.0 - r; 
        gl_FragColor = vec4( vColor, alpha * 0.8 );
    }
    `;

    // --- INITIALIZATION ---
    init();
    animate();

    function init() {
        const loader = document.getElementById('load-bar');
        loader.style.width = '100%';

        container = document.getElementById( 'canvas-container' );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 3000 );
        camera.position.z = 1200;
        camera.position.y = 400;

        renderer = new THREE.WebGLRenderer( { antialias: false, powerPreference: "high-performance" } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        // Interaction Sphere - FIXED VISIBILITY (Cyan Wireframe)
        const sphereGeo = new THREE.IcosahedronGeometry( 1, 32 );
        const sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, // Cyan
            wireframe: true, 
            transparent: true, 
            opacity: 0.5
        });
        const sphereInnerMat = new THREE.MeshBasicMaterial({
            color: 0x001133, // Dark blue core
            transparent: true,
            opacity: 0.2
        });
        
        interactionSphere = new THREE.Mesh( sphereGeo, sphereInnerMat );
        const wireframe = new THREE.Mesh( sphereGeo, sphereMat );
        wireframe.scale.set(1.02,1.02,1.02);
        interactionSphere.add(wireframe);

        interactionSphere.scale.setScalar(params.sphereRadius);
        scene.add( interactionSphere );

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 

        // --- GPGPU SETUP ---
        initComputeRenderer();

        // --- PARTICLES MESH ---
        initParticles();

        controls = new OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;

        const gui = new GUI({ container: document.getElementById('gui-container') });
        const physicsFolder = gui.addFolder('DULA PHYSICS');
        physicsFolder.add( params, 'M_vac', 0.0001, 0.02 ).name('M_vac (Viscosity)').listen();
        physicsFolder.add( params, 'flowSpeed', 0.1, 5.0 ).name('Force Energy');
        physicsFolder.add( params, 'forceFieldScale', 0.001, 0.02 ).name('Lattice Scale');
        
        const interactFolder = gui.addFolder('INTERACTION');
        interactFolder.add( params, 'sphereRadius', 50, 300 ).name('Obstacle Size').onChange(v => {
            interactionSphere.scale.setScalar(v);
        });
        interactFolder.add( params, 'sphereRepulsion', 1.0, 20.0 ).name('Repulsion Force');

        const visualFolder = gui.addFolder('VISUALS');
        visualFolder.add( params, 'colorSaturation', 0.1, 3.0 ).name('Plasma Intensity');
        
        physicsFolder.open();

        window.addEventListener( 'resize', onWindowResize );
        document.addEventListener( 'mousemove', onMouseMove );
        document.addEventListener( 'mousedown', onMouseDown );
        document.addEventListener( 'mouseup', onMouseUp );

        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
        }, 800);
    }

    function initComputeRenderer() {
        gpuCompute = new GPUComputationRenderer( TEXTURE_WIDTH, TEXTURE_WIDTH, renderer );
        
        // FIXED: iOS/Safari Compatibility Check
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if ( isSafari ) {
            gpuCompute.setDataType( THREE.HalfFloatType );
        }

        const dtPosition = gpuCompute.createTexture();
        const dtVelocity = gpuCompute.createTexture();

        fillTextures( dtPosition, dtVelocity );

        velocityVariable = gpuCompute.addVariable( "textureVelocity", velocityFragmentShader, dtVelocity );
        positionVariable = gpuCompute.addVariable( "texturePosition", positionFragmentShader, dtPosition );

        gpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );
        gpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );

        const error = gpuCompute.init();
        if ( error !== null ) { console.error( error ); }

        velocityVariable.material.uniforms[ "time" ] = { value: 0.0 };
        velocityVariable.material.uniforms[ "M_vac" ] = { value: params.M_vac };
        velocityVariable.material.uniforms[ "flowSpeed" ] = { value: params.flowSpeed };
        velocityVariable.material.uniforms[ "forceScale" ] = { value: params.forceFieldScale };
        velocityVariable.material.uniforms[ "spherePos" ] = { value: new THREE.Vector3() };
        velocityVariable.material.uniforms[ "sphereRadius" ] = { value: params.sphereRadius };
        velocityVariable.material.uniforms[ "sphereRepulsion" ] = { value: params.sphereRepulsion };

        positionVariable.material.uniforms[ "time" ] = { value: 0.0 };
        positionVariable.material.uniforms[ "delta" ] = { value: 0.0 };
    }

    function initParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array( TEXTURE_WIDTH * TEXTURE_WIDTH * 3 );
        const uvs = new Float32Array( TEXTURE_WIDTH * TEXTURE_WIDTH * 2 );

        let p = 0;
        for ( let j = 0; j < TEXTURE_WIDTH; j ++ ) {
            for ( let i = 0; i < TEXTURE_WIDTH; i ++ ) {
                // FIXED: Offset to center of texel for precise GPGPU lookup
                const u = ( i + 0.5 ) / TEXTURE_WIDTH;
                const v = ( j + 0.5 ) / TEXTURE_WIDTH;
                
                uvs[ p * 2 + 0 ] = u;
                uvs[ p * 2 + 1 ] = v;
                
                positions[ p * 3 + 0 ] = u;
                positions[ p * 3 + 1 ] = v;
                positions[ p * 3 + 2 ] = 0;
                
                p ++;
            }
        }

        geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) ); 
        geometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

        particleUniforms = {
            texturePosition: { value: null },
            textureVelocity: { value: null },
            saturation: { value: 1.0 }
        };

        const material = new THREE.ShaderMaterial( {
            uniforms: particleUniforms,
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        } );

        particles = new THREE.Points( geometry, material );
        scene.add( particles );
    }

    function fillTextures( texturePosition, textureVelocity ) {
        const posArray = texturePosition.image.data;
        const velArray = textureVelocity.image.data;

        for ( let k = 0, kl = posArray.length; k < kl; k += 4 ) {
            posArray[ k + 0 ] = ( Math.random() - 0.5 ) * BOUNDS;
            posArray[ k + 1 ] = ( Math.random() - 0.5 ) * BOUNDS;
            posArray[ k + 2 ] = ( Math.random() - 0.5 ) * BOUNDS;
            posArray[ k + 3 ] = 1;

            velArray[ k + 0 ] = 0;
            velArray[ k + 1 ] = 0;
            velArray[ k + 2 ] = 0;
            velArray[ k + 3 ] = 1;
        }
    }

    function onMouseDown( event ) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera( mouse, camera );

        const intersects = raycaster.intersectObject( interactionSphere );
        if ( intersects.length > 0 ) {
            controls.enabled = false;
            isDragging = true;
            let normal = new THREE.Vector3();
            camera.getWorldDirection(normal);
            plane.normal.copy(normal).negate();
            plane.constant = -interactionSphere.position.dot(plane.normal);
        }
    }

    function onMouseUp() {
        controls.enabled = true;
        isDragging = false;
    }

    function onMouseMove( event ) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        if ( isDragging ) {
            raycaster.setFromCamera( mouse, camera );
            let intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane( plane, intersectPoint );
            if(intersectPoint) {
                intersectPoint.x = Math.max(-BOUNDS_HALF, Math.min(BOUNDS_HALF, intersectPoint.x));
                intersectPoint.y = Math.max(-BOUNDS_HALF, Math.min(BOUNDS_HALF, intersectPoint.y));
                intersectPoint.z = Math.max(-BOUNDS_HALF, Math.min(BOUNDS_HALF, intersectPoint.z));
                interactionSphere.position.copy(intersectPoint);
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );

        const now = performance.now();
        const delta = Math.min(0.05, (now - (animate.lastTime || now)) / 1000) * params.timeScale;
        animate.lastTime = now;

        controls.update();

        velocityVariable.material.uniforms[ "time" ].value = now * 0.001;
        velocityVariable.material.uniforms[ "M_vac" ].value = params.M_vac;
        velocityVariable.material.uniforms[ "flowSpeed" ].value = params.flowSpeed;
        velocityVariable.material.uniforms[ "forceScale" ].value = params.forceFieldScale;
        velocityVariable.material.uniforms[ "spherePos" ].value.copy( interactionSphere.position );
        velocityVariable.material.uniforms[ "sphereRadius" ].value = params.sphereRadius;
        velocityVariable.material.uniforms[ "sphereRepulsion" ].value = params.sphereRepulsion;

        positionVariable.material.uniforms[ "time" ].value = now * 0.001;
        positionVariable.material.uniforms[ "delta" ].value = delta;

        particleUniforms[ "saturation" ].value = params.colorSaturation;

        gpuCompute.compute();

        particleUniforms[ "texturePosition" ].value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;
        particleUniforms[ "textureVelocity" ].value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;

        renderer.render( scene, camera );
    }

</script>
</body>
</html>
